// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use hashing::{generate_ecdsa_key_pair, generate_ed25519_key_pair};
use methods::{
    ECDSAGUEST_ELF, ECDSAVERIFYGUEST_ELF, EDDSAGUEST_ELF, EDDSAVERIFYGUEST_ELF, FIBONACCIGUEST_ELF,
    KECCAK256GUEST_ELF, MIMCGUEST_ELF, POSEIDONGUEST_ELF, SHA256GUEST_ELF,
};
use risc0_zkvm::{default_executor, ExecutorEnv};

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // KECCAK256
    print!("keccak256 - ");
    generate_hash(KECCAK256GUEST_ELF);

    // SHA256
    print!("sha256 - ");
    generate_hash(SHA256GUEST_ELF);

    // Poseidon
    print!("poseidon - ");
    generate_hash(POSEIDONGUEST_ELF);

    // MIMC
    print!("mimc - ");
    generate_hash(MIMCGUEST_ELF);

    // ECDSA
    generate_ecdsa_key_pair_sign_and_verify(ECDSAGUEST_ELF, ECDSAVERIFYGUEST_ELF);

    // EDDSA
    generate_eddsa_key_pair_sign_and_verify(EDDSAGUEST_ELF, EDDSAVERIFYGUEST_ELF);

    // Fibonacci
    print!("fibonacci - ");
    calculate_fibonacci(FIBONACCIGUEST_ELF);
}

fn generate_hash(elf: &[u8]) {
    let input = b"Hello World".to_vec();
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();
    let executor = default_executor();
    let executor_info = executor.execute(env, elf).unwrap();
    print!("{}", executor_info.cycles());
    println!();
}

fn calculate_fibonacci(elf: &[u8]) {
    let input = 64000;
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();
    let executor = default_executor();
    let executor_info = executor.execute(env, elf).unwrap();
    print!("{}", executor_info.cycles());
    println!();
}

fn generate_ecdsa_key_pair_sign_and_verify(sign_elf: &[u8], verify_elf: &[u8]) {
    let (signing_key, _) = generate_ecdsa_key_pair();

    // Sign
    let input = b"Hello World".to_vec();
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .write_slice(&signing_key.to_bytes())
        .build()
        .unwrap();
    let executor = default_executor();
    let executor_info = executor.execute(env, sign_elf).unwrap();
    println!("ecdsa sign - {}", executor_info.cycles());

    // Verify
    let journal = executor_info.journal;
    let signature: p256::ecdsa::Signature = journal.decode().unwrap();
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .write(&signature)
        .unwrap()
        .write_slice(&signing_key.to_bytes())
        .build()
        .unwrap();
    let executor = default_executor();
    let executor_info = executor.execute(env, verify_elf).unwrap();
    println!("ecdsa verify - {}", executor_info.cycles());
}

fn generate_eddsa_key_pair_sign_and_verify(sign_elf: &[u8], verify_elf: &[u8]) {
    let (signing_key, verifying_key) = generate_ed25519_key_pair();

    // Sign
    let input = b"Hello World".to_vec();
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .write(&signing_key)
        .unwrap()
        .build()
        .unwrap();
    let executor = default_executor();
    let executor_info = executor.execute(env, sign_elf).unwrap();
    println!("eddsa sign - {}", executor_info.cycles());

    // Verify
    let journal = executor_info.journal;
    let signature: ed25519_dalek::Signature = journal.decode().unwrap();
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .write(&signature)
        .unwrap()
        .write(&verifying_key)
        .unwrap()
        .build()
        .unwrap();
    let executor = default_executor();
    let executor_info = executor.execute(env, verify_elf).unwrap();
    println!("eddsa verify - {}", executor_info.cycles());
}
